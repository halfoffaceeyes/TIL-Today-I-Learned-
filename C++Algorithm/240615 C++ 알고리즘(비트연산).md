STL(Standard Template Libarary) == 많은 자료구조가 이미 만들어져 있음 == array list 구현해서 사용
# 비트 연산
* 컴퓨터는 0과1로 연산하는데 컴퓨터에 맞춰서 연산을 시켜서 연산 속도를 올릴 수 있음

|비트연산자|a=0b1010, b=0b0100|
|&|AND| a & b = 0b0000|
|'|'|AND| a & b = 0b0000|
|&|AND| a & b = 0b0000|
|&|AND| a & b = 0b0000|
|&|AND| a & b = 0b0000|

## 비트 shift에서 범위를 초과하는 경우
ex) 23<<100 == 23 * 2**100 인데 <br>
java와 c++의 경우에는 변수가 담을 수 있는 정수의 크기가 있음 <br>
int = 32bit 2147483647 <br>
long = 64bit  <br>
23<<100의 경우 마지막 32bit자리만 남아서 0이라는 값으로 변경됨  <br>
x << n == (x* 2**n) %32라고 생각하는게 맞음 <br>

## 비트연산을 배우는 이유
30명이 밥을 먹으면 1, 먹지 않았을 때 0이라고 했을 때, <br>
모두 밥을 먹었는지 확인하려면 반복문을 돌면서 30번의 반복연산이 필요한데 <br>
만약 2진수로 표현을 한다면? <br>
30자리 비트가 형성됨 == 비트마스킹 <br>
1<<31 -1 == 30자리 1  <br>
비트연산은 배열로 저장하는것이 아니라 배열을 2진수 형식으로 저장한다고 생각하는 것이 편함  <br>

그럼 특정 자리수만을 바꾸는 것은 어떻게 할 것인가?? <br>
덧셈을 이용하면 앞자리가 바뀔 가능 성이 있기 때문에 덧셈을 사용하지 않음 => OR 연산을 사용 <br>
100110101 || 00000010으로 2번째 위치만 밥을 먹었다고 표시할 수 있음  <br>

x번은 밥을 먹었나? <br>
bit & (1 << x) !=0 <br>
(bit >> x) & 1 ==1 <br>
(bit |(1 << x)) == bit <br>
bit가 32가 넘어가면 bit연산이 어려움

# 연결리스트
c++에서 vector는 동적리스트를 제공하는 라이브러리 <br>
vector에서 특정 위치를 빠르게 찾을 수 있음 왜냐하면 메모리 주소값을 알면 위치를 빠르게 찾을 수 있음 <br>
그럼 탐색은 빠르지만 삽입하는 과정에서 원래의 메모리 값들을 뒤로 밀어야하므로 삽입의 시간이 오래걸림 <br>
이때 연결리스트 라이브러리를 사용한다면 삽입은 빨리지겠지만 탐색에서 오래 걸림 <br>

## 연결리스트와 알고리즘
* 알고리즘 문제를 풀때, 보통은 100000이상의 수가 제공되는데 이때 횟수가 적은 변수나 함수가 키가 될 수 있음
* 함수의 실행횟수가 적은 함수의 경우에는 오래걸리는 자료 구조를 사용해도 문제가 없을 것이고 함수의 실행횟수가 많은 함수는 자료구조를 잘 선택해야함
* 배열에서의 삭제는 O(1): O(N)이 아님 왜냐하면 O(N)은 순서가 보장된 배열인 경우, O(1)이 걸리는 이유는 삭제하는 배열의 원소에 맨뒤의 원소로 대체하고 맨 뒤 원소를 제거하면 되기때문에
* 연결리스트에서는 더미노드를 헤드로 사용하면 연결리스트를 변경하기 쉬운 이점이 있음
* 라이브러리 연결리스트는 연결리스트 변경의 시간이 O(N)이걸림

* soft delete 데이터 베이스에서 행이 삭제되지 않음
* hard delete는 데이터 베이스에서 행을 삭제함
* 연결리스트에서 soft delete를 이용하여 업데이트를 할 수 있음
    * 예를 들어 연결리스트에 갱신한 값으로 새로운 노드로 추가하고 원래 있던 노드가 참조되지 않도록 만들어줌