# 트리
* 다음 3가지 조건중 2개를 만족하는 모든 자료구조를 뜻함
    * Connected Graph(연결되어 있다)
    * Aycylic(사이클이 없다)
    * V=E+1 (정점이 간선보다 1개 많다)
## 트리의 용어
* Parent node / Child node (부모노드 / 자식노드) : 연결된 두 노드 중 위에 있는 노드를 부모 노드, 아래에 있는 노드를 자식노드
* Ancestor / descendent (조상 / 자손) : 노드 V에서 부모 노드로만 계속 이동해서 노드 U로 갈 경우, U는 V의 조상이고, V는 U의 자손
* Root node(루트) : 부모 노드가 없는 노드
* Leaf node(리프) : 자식 노드가 없는 노드
* depth of a node(깊이) : 루트 노드로부터 해당 노드까지 이동하기 위해 거쳐야 하는 간선의 수
    * 루트 노드의 깊이 : 0
    * level이라고도 불림
* height of a node(높이) : 해당 노드부터 가장 먼 리프 노드까지 ㅣㅇ동하기 위해 거쳐야 하는 간선의 수
    * 리프노드의 높이 : 0
    * 루트노드의 높이 == 트리의 높이
* subtree (서브트리) : 어떤 노드와 부모 노드 간의 연결을 끊으면 해당 노드를 루트 노드로 만들어지는 새로운 트리
* size of tree (트리의 크기) : 노드의 개수

## 트리의 종류
### Binary Search Tree
* 원소의 중복을 허용하지 않고, 왼쪽 서브트리는 자기보다 작은 값, 오른쪽 서브트리는 자기보다 큰 값을 저장하는 트리
* c++의 std::set에서 Binary Search Tree 중 Red Black Tree가 이용
### Skewed Binary Tree
* 원소의 삽입/삭제/탐색의 시간복잡도가 모두 O(트리의 높이)
* 연결리스트와 비슷한 형태
### Balanced Binary Tree
* 레드블랙트리
* 234트리
## 순회
### 전위 순회(pre-order)
* 자신 -> 왼쪽 서브트리 -> 오른쪽 서브트리 순서로 방문
### 중위 순회(in-order)
* 왼쪽 서브트리 -> 자신 -> 오른쪽 서브트리 순서로 방문
* Binary Search Tree에서 key를 정렬한 결과와 같음
### 후위 순회
* 왼쪽 서브트리 -> 오른쪽 서브트리 -> 자신 순서로 방문 
* 자식 서브트리를 모두 방문한 후에 자신을 방문하므로 자식 노드에서 계산된 결과를 자신이 활용
    * 계산기, 세그먼트 트리
## 가장 가까운 공통 조상 찾기(LCA)
* Lowest Common Ancestor
* 특정 두개의 노드(x,y)의 가장 가까운 공통조상을 찾기
    * X의 조상을 리스트업을 하고, Y의 조상을 리스트업을 할 때, 높은곳에서 낮은 순으로 리스트업
    * 두 리스트를 순회하면서 마지막으로 동일한 노드가 조상노드


# 그래프
* 인접 행렬과 인접 리스트로 구현할 수 있는데 각각의 장단점이 존재
* 인접 행렬로 구현 : std::vector로 구현, 구현량이 적어서 가장 많이 쓰이는 방식이므로 배열에 저장함
    * 장점
        * 구현이 쉬움
        * 간선으로 이어진 정점 정보가 하나의 배열에 담기므로, 배열에 할 수 있는 모든 작업(정렬, 삭젝)을 자유롭게 할 수 있음
    * 단점
        * std::vector에 정점을 push하는 데 오버헤드가 생김
        * 여러 개의 테스트케이스를 처리할 경우, 메모리에 빈 공간이 많이 생김
        * 메모리상에 각각의 배열이 파편화되어 저장되므로 캐시 효율이 떨어짐

* 연결 리스트로 구현 : std::vector를 대신하여 정점마다 인접한 정점의 개수는 미리 알지 못하지만, 총 간선의 개수는 알고 있어 사용할 메모리만 정확하게 미리 할당할 수 있음
    * 장점 
        * 메모리를 효율적으로 사용(테스트케이스가 많으면 차이가 큼)
    * 단점
        * 가독성이 떨어짐
        * 정점 정보를 연결 리스트에 저장하므로 정렬하거나 삭제하는 데 어려움이 있음
        * 연결리스트 순회는 기본적으로 배열보다 느림

* 1차원 배열로 구현 : 2차원으로 놓인 여러 개의 정점 리스트를 일렬로 잇는 방법 
    * 장점
        * 캐시 효율이 가장 뛰어남
    * 단점
        * 정점마다 인접한 정점의 개수를 미리 전처리로 구해야되어 실시간으로 간선이 추가/삭제되는 문제를 풀 수 없음
        * 가독성이 떨어짐
        
