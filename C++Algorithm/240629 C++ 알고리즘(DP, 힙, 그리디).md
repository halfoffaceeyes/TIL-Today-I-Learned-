# DP
* DP는 수학적 귀납법에서 착안한 방식
* 귀납법을 만족하는 점화식을 찾아 recursive와 memoization을 활용해 문제를 해결하는 방식
    * 수학적 귀납법 : 주어진 등식이 N=1일 떄 성립함을 증명하고, N=n일 때 성립함을 가정한 뒤, n+1일 때 성립함을 증명
* 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

## DP 적용 조건
* 최적 부분 문제 구조
    * 최적화의 원칙을 만족해야함
        * 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적
* 중복 부분 문제 구조
    * 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제를 해결
    * 순환적인 관계를 명시적으로 표현하기 위해 점화식 사용
    * 작은 문제의 해는 저장하여 필요시 마다 참조하여 중복 계산을 피함

# 힙
* 우선순위 큐를 위해 만들어진 자료구조
* 모든 노드에 대해서 부모와 자식 간에 일정한 대소 관계가 성립하는 완전 이진트리
* 부모가 가지는 값은 자식보다 무조건 크거나 작아야 함
* 부모가 자식보다 큰 값을 가지면 최대힙, 작으면 최소 힙
* 자료를 정렬하는 것이 아님

## 배열을 이용하 힙 구현
* 루트 노드의 인덱스가 0으로 시작하는 경우
    * 부모의 인덱스 = (자식의 인덱스-1)  /2
    * 왼쪽 자식 인덱스 = 부모의 인덱스 * 2 + 1
    * 오른쪽 자식 인덱스 = 부모의 인덱스 * 2 +1

* 루트 노드의 인덱스가 1로 시작하는 경우
    * 부모의 인덱스 = 자식의 인덱스 / 2
    * 왼쪽 자식 인덱스 = 부모의 인덱스 * 2
    * 오른쪽 자식 인덱스 = 부모의 인덱스 * 2 + 1

### 삽입
* 배열의 맨 마지막에 데이터를 삽입, 힙 구조를 유지하도록 부모와 값을 바꾸면서 올라감 => 힙의 삽입을 거품이 올라가는 모양(Bubble up)

### 삭제
* 루트 노드에 위치하는 제일 큰 데이터(최대 힙기준)를 제거한 뒤, 맨 마지막 데이터를 루트 노드로 옮기고, 힙 구조에 맞게 자식과 값을 바꾸면서 이동
* 자식과 값을 비교할 때는 둘 중 더 큰 값과 비교하여 거품이 내려가는 모양과 유사(Bubble down)

### 힙의 시간복잡도
* 완전 이진트리는 height balanced한 트리이므로 삽입과 삭제 모두 최악의 경우에 루트부터 리프까지 값을 비교하기 때문에 시간복잡도는 O(트리의 높이)인 O(logN)

```c++
#include <algorithm>
#include <cassert>

class MaxHeap {
#define parent (i >> 1)
#define left (i << 1)
#define right (i << 1 | 1)

	static constexpr size_t MAX_N = 100000;

	int data[MAX_N + 1];
	size_t size;

    public:
        MaxHeap() = default;

        // x 삽입
        void push(int x) {
            data[++size] = x;
            for (int i = size; parent != 0 && data[parent] < data[i]; i >>= 1) {
                std::swap(data[parent], data[i]);
            }
        }

        // 최대값 리턴
        int top() const {
            assert(size != 0);
            return data[1];
        }

        // 최대값 삭제
        void pop() {
            assert(size != 0);
            data[1] = data[size--];
            for (size_t i = 1; left <= size;) {
                if (left == size || data[left] > data[right]) {
                    if (data[i] < data[left]) {
                        std::swap(data[i], data[left]);
                        i = left;
                    } else {
                        break;
                    }
                } else {
                    if (data[i] < data[right]) {
                        std::swap(data[i], data[right]);
                        i = right;
                    } else {
                        break;
                    }
                }
            }
    	}

#undef parent
#undef left
#undef right
};

```


# 그리디
* 최적해를 구하기 위한 근시안저긴 방법
* 여러 경우 중 하나를 선택할 때마다 그 순간에 최적인 해를 선택하면서 최종 해에 도달
* 각 선택 시점에서 이루어지는 결정이 지역적으로는 최적이라면, 그 결정들이 모여서 만든 답이 최적해라는 보장이 있어야 함
## 그리디 동작 과정
* 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가 
* 실행 가능서 검사 : 새로운 부분해 집합이 실행가능한지 확인(제약 조건을 위반하지 않는지 검사)
* 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인, 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작

## 그리디 설계
* 탐욕적 선택 속성 : 최적해로 갈 수 있음을 보이고, 항상 안전하다는 것을 확인 할 수 있어야 함
* 최적 부분 구조 : 최적화 문제를 정형화 해야하고, 하나의 선택을 풀어야 할 하나의 하위 문제가 남아야함
* 원 문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적 해 임을 증명해야 함

