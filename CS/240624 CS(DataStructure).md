# 자료 구조
* 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합
# 복잡도
## 시간복잡도
* 문제를 해결하는데 걸리는 시간과 입력의 함수 관계
* 얼마나 오랜시간이 걸리는지 나타내는 데 사용
* 효율적인 코드로 개선하는데 쓰이는 척도
### 빅오표기법
* 입력범위 n을 기준으로 해서 로직이 몇번 반복되는지 나타내는 것
* 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항들도 제거(연산량이 가장 많이 커지는것은 최고차항이기 때문)

## 공간 복잡도
* 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
* 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

## 자료구조에서의 시간복잡도
* 평균 시간 복잡도
|자료구조|접근|탐색|삽입|삭제|
|:---:|:---:|:---:|:---:|:---:|
|배열(array)|O(1)|O(n)|O(n)|O(n)|
|스택(stack)|O(n)|O(n)|O(1)|O(1)|
|큐(queue)|O(n)|O(n)|O(1)|O(1)|
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(1)|O(1)|O(1)|O(1)|
|이진 탐색 트리(BST)|O(logn)|O(logn)|O(logn)|O(logn)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|

* 최악의 시간복잡도
|자료구조|접근|탐색|삽입|삭제|
|:---:|:---:|:---:|:---:|:---:|
|배열(array)|O(1)|O(n)|O(n)|O(n)|
|스택(stack)|O(n)|O(n)|O(1)|O(1)|
|큐(queue)|O(n)|O(n)|O(1)|O(1)|
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(n)|O(n)|O(n)|O(n)|
|이진 탐색 트리(BST)|O(n)|O(n)|O(n)|O(n)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|

# 선형 자료구조
* 요소가 일렬로 나열되어 있는 자료구조
## 연결 리스트
* 데이터를 감싼 노드를 포인터롤 연결해서 공간적인 효율성을 극대화시킨 자료구조
* 삽입과 삭제가 O(1), 탐색은 O(n)
* prev포인터와 next포인터로 앞 뒤의 노드를 연결 시킨것
* 맨 앞의 노드를 head라고 부름
### 종류
* 싱글 연결 리스트 : next 포인터만 가짐
* 이중 연결 리스트 : next 포인터와 prev포인터를 가짐
* 원형 이중리스트 : 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 구조

#### 이중연결리스트
* 이중 연결 리스트는 앞에서 요소를 넣는 push_front(), 뒤에서 요소를 넣는 push_back(), 중간에 요소를 넣는 insert() 등의 함수가 있음
```c++
#include <bits/stdc__.h>
using namespace std;
int main(){
    list<int> a;
    for (int i=0; i<10; i++)a.push_back(i);
    for (int i=0; i<10;i++)a.push_front(i);
    auto it = a.begin(); it++;
    a.insert(it,1000);
    gor (auto.it : a) cout << it << " ";
    cout << '\n';
    a.pop_front();
    a.pop_back();
    for(auto it :a) cout << it << " ";
    cout << '\n';
    return 0
}

// 9 1000 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9
// 1000 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8
```

## 배열
* 같은 타입의 변수들로 이루어져 있고 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
* 중복을 허용하고 순서가 있음
* 탐색에 O(1)이고 랜덤 접근이 가능, 삭제와 삽입은 O(n) => 데이터 추가와 삭제를 많이 하는 것은 연결리스트, 탐색을 많이 하는 것은 배열로 하는 것이 좋음
* 인덱스에 해당하는 원소를 빠르게 접근해야하거나 간단하게 데이터를 쌓고 싶을때 사용

### 랜덤 접근과 순차적 접근
* 직접접근==랜덤 접근은 동일한 시간에 배열과 같은 순차적 데이터가 있을 때 임의의 접근할 수 있는 기능(인덱스를 알면 바로 접근이 가능함)
* 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대

### 배열과 연결리스트 비교
* 배열은 상자를 순서대로 나열한 데이터 구조, 몇번째 상자인지 알면 해당 상자의 요소를 끄집어 낼 수 있음
* 연결리스트는 상자를 선으로 연결한 형태의 구조, 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다는 점이 다름
* 따라서 탐색하는 과정에서 배열은 빠르지만 연결리스트는 느림
* 연결리스트는 데이터의 추가 삭제가 더 빠름

```c++
#include <bits/stdc++.h>
using namespace std;
int a[10];
int main(){
    for (int i = 0; i<10; i++) a[i]=i;
    for (auto it : a) cout << it << " ";
    cout << '\n';
    return 0    
}

// 0 1 2 3 4 5 6 7 8 9
```

## 벡터
* 동적으로 요소를 할당할 수 있는 동적 배열
* 컴파일 시점에 개수를 모르면 사용하는 자료구조
* 중복을 허용하고 순서가 있고 랜덤 접근이 가능
* 탐색과 맨뒤의 요소를 삭제하거나 삽입하는데 O(1)
* push_back을 진행한다면 매번 1의 크기가 증가하는 것이 아니라 2의 제곱승 + 1마다 크기를 2배로 늘림

ex) push_back(i){int i=1; i <10: i ++}의 경우,
1이 들어가면 벡터의 용량은 1,
2가 들어가면 벡터의 용량은 2,
3이 들어가면 벡터의 용량은 4,
4=>4, 5=>8, 6=>8, 7=>8, 8=>8, 9=>16식으로 용량이 다차면 2의 거듭제곱꼴로 용량이 증가함

* 이 때 ci를 i 번째 push_back()을 할 때 드는 비용은 ci는 1또는 1+ 2^k

* n번 push_back()을 할 때의 비용 T(n)
    * T(n) = 3n-1

```c++
#include <bits/stdc++.h>
using namespace std;
vector<int> v;
int main(){
    for (int i=1; i<=10; i++) v.push_back(i);
    for (int a : v) cout << a << " ";
    cout << "\n";
    v.pop_back();

    for (int a : v) cout << a << " ";
    cout << "\n";
    
    v.erase(v.begin(), v.begin() + 1);
    
    for (int a : v) cout << a << " ";
    cout << "\n";
    
    auto a = find(v.begin(), v.end(), 100);
    if (a==v.end()) cout << "not found" << "\n";
    
    fill(v.begin(),v.end(),10);
    for (int a : v) cout << a << " ",
    cout << "\n";
    v.clear();
    for (int a : v) cout << a << " ";
    cout << "\n";

    return 0;
}

// 1 2 3 4 5 6 7 8 9 10
// 1 2 3 4 5 6 7 8 9
// 2 3 4 5 6 7 8 9
// not found
// 10 10 10 10 10 10 10 10 
```

## 스택
* Last In First Out, LIFO 후입선출
* 재귀적인 함수, 알고리즘에 사용되며 웹브라우저 방문 기록에 사용
* 삽입, 삭제에 O(1), 탐색에 O(n)
```c++
#include <bits/stdc++.h>
using namespace std;
stack<int> stk;
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    for (int i=0; i < 10; i++)stk.push(i);
    while (stk.size()) {
        cout << stk.top() << " ";
        stk.pop();
    }
}
// 9 8 7 6 5 4 3 2 1 0
```

## 큐
* First In First Out, FIFO 선입선출
* CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비우선탐색, 캐시 등에 사용
* 삽입 삭제에 O(1), 탐색에 O(n)
```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    queue<int> q;
    q.push(1);
    cout << q.front() << "\n";
    q.pop();
    cout << q.size() << "\n";
    return 0;
}
// 1
// 0
```
# 비선형 자료구조
* 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조
* 트리나 그래프
## 그래프
* 정점과 간선으로 이루어진 자료 구조
### 정점과 간선
* 어떠한곳엥서 어떠한 곳으로 무언가를 통해 간다고 했을때 
* 정점(vertex) : 어떠한곳
* 간선(edge) : 무언가
    * 단방향 간선 : 한쪽방향으로만 연결된 간선
    * 양방향 간선 : 양쪽방향으로 연결된 간선
    * indegree : 정점으로 들어오는 간선
    * outdegree : 점점에서 나가는 간선
* 가중치 : 간선과 정점사이에 드는 비용

## 트리
* 그래프 중 하나로, 정점과 간선으로 이루어져 있고 트리 구조로 배열된 계층적 데이터의 집합
* 루트 노드, 내부 노드, 리프 노드로 구성
### 트리의 특징
1. 부모, 자식 계층 구조를 가짐
2. V-1=E, 간선수 = 노드수 -1
3.  임의의 두 노드 사이의 경로는 유일무이하게 존재, 트리 내의 노드와 노드까지의 경로는 반드시 존재
### 트리의 구성
* 루트노드 : 가장 위에 있는 노드
* 내부 노드 : 루트 노드와 리프노드 사이의 노드
* 리프노드 : 자식노드가 없는 노드
* 트리의 높이와 레벨
    * 깊이 : 트리에서의 깊이는 각 노드마다 다름, 루트노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
    * 높이 : 루트 노드부터 리프 노드까지 거리 중 가장 긴거리를 의미
    * 레벨 : 보통 깊이와 같은 의미를 가짐
    * 서브트리 : 트리 내의 하위 집합
### 이진 트리
* 자식의 노드 수가 두개 이하인 트리
* 이진 트리 종류 
    * 정 이진트리(full binary tree) : 자식 노드가 0개 또는 두개인 이진트리
    * 완전 이진트리(complete binary tree) : 왼쪽에서부터 채워져 있는 이진트리. 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있음
    * 변질 이진트리(degenerate binary tree) : 자식 노드가 하나밖에 없는 이진트리
    * 포화 이진트리(perfect binary tree) : 모든 노드가 꽉 차 있는 이진트리
    * 균형 이진트리(balanced binary tree) : 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진트리를 의미, map과 set을 구성하는 레드 블랙 트리는 균형 이진트리 중 하나

#### 이진 탐색 트리
* 오른쪽 하위 트리에는 노드 값보다 큰 값이 있는 노드만 포함, 왼쪽 하위 트리에는 노드 값보다 작은 값이 들어 있는 트리
* 왼쪽에는 작은 값, 오른쪽에는 큰값이 이미 정해져 있어서 검색을 하기에 용이 함
* 탐색의 시간 평균 O(logn), 최악의 경우O(n) = > 삽입 순서에 따라 선형적일 수 있기 때문

#### AVL 트리
* Adelson-Velsky and Landis tree
* 이진 탐색 트리의 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진탐색트리
* 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있음
* 탐색,삽입,삭제 모두 O(logn)


#### 레드 블랙 트리
* 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 O(logn)
* 각 노드는 빨간색 도는 검은 색의 색상을 나타내는 추가비트를 저장, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용


## 힙
* 완전 이진트리 기반의 자료 구조, 최소힙과 최대힙
    * 최대힙 : 루트 노드에 있는 키는 모든 자싱에 있는 키 중에서 가장 커야 함. 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져 있음
    * 최소힘 : 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키중 최솟값. 각 노드의 자식노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함

* 최대힙의 삽입
    * 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입
    * 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족
* 최대힙의 삭제
    * 최댓값이 루트노드이므로 삭제되고 마지막 노드와 루트노드를 스왑한 후에 삽입 연산과 같이 스왑으로 재구성


## 우선순위 큐
* 우선순위 대기열, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조
* 힙을 기반으로 구현

```c++
#include <bits/stdc++.h>
using namespace std;
priority_queue<int, vector<int>, greater<int> > pq; // 오름차순
// priority_queue<int, vector<int>, less<int> > pq; // 내림차순
int main(){
    pq.push(5);
    pq.push(4);
    pq.push(3);
    pq.push(2);
    pq.push(1);
    cout << pq.top() << "\n";
    return 0;
}
//  1
```

## 맵
* 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
* 레드 블랙트리 자료 구조를 기반으로 형성
* string : int 형태로 값을 할당해야 할때 사용
* map을 순회할 때는 키에 해당하는 값을 first, 키에 매핑된 값에 해당하는 second로 탐색 가능

## 셋
* 특정 순서에 따라 고유한 요소를 저장하는 컨테이너
* 중복되는 요소는 없고 오로지 유니크 값만 저장

## 해시 테이블
* 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
* 삽입, 삭제, 탐색 시 평균 O(1), unordered_map으로 구현

Q. 그래프와 트리의 차이점
* 그래프는 정점과 간선으로 이루어진 자료 구조
* 트리는 그래프중 하나로 일종의 계층적 데이터 집합
* 트리는 루트노드, 내부노드, 리프노드 등으로 구성

Q. 이진 탐색 트리는 어떤 문제점이 있고 이를 해결하기 위한 트리
* 선형적으로 구성될 때 시간 복잡도가 O(n)으로 커지는 문제점
* 선형적으로 구성하지 않고 균형 잡힌 트리로 나온 AVL이나 레드블랙 트리가 있음
* AVL 트리는 스스로 균형을 잡는 이진 트리로 각 서브 트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있음
    * 탐색, 삽입, 삭제 모두 O(logn), 삽입 삭제 시 균형이 맞지 않는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡음
